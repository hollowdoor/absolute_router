{"version":3,"file":"absolute-router.min.js","sources":["../src/lib/url_stuff.js","../src/lib/return_view.js","../src/lib/tree.js","../src/lib/route_tree.js","../src/lib/router.js","../src/lib/throw_error.js"],"sourcesContent":["const getSearch = (()=>{\n    if(typeof window !== 'undefined' && typeof document !== 'undefined'){\n        if(window['URLSearchParams']){\n            return function getSearch1(url){\n                let full = {};\n                let search = new URLSearchParams(url.search);\n                let entries = search.entries();\n                while(true){\n                    let item = entries.next();\n                    if(item.done){break;}\n                    let [key, value] = item.value;\n                    full[key] = value;\n                }\n                return full;\n                /*console.log('entries.length ',entries.length)\n                console.log('search.entries() ',search.entries());\n                return search.entries().reduce((full, [key, value])=>{\n                    full[key] = value;\n                    return full;\n                }, {});*/\n            };\n        }\n    }\n\n    return function getSearch0(url){\n        if(!url.search.length){\n            return {};\n        }\n        let str = url.search.slice(1);\n\n        return str.split('&').reduce((full, param)=>{\n            const [name, value] = param.split('=');\n            full[name] = value;\n            return full;\n        }, {});\n    };\n})();\n\nconst getURL = (()=>{\n    if(typeof window !== 'undefined' && typeof document !== 'undefined'){\n        if(window['URL']){\n            return function getURL0(loc, base){\n                if(/^http/.test(loc)){\n                    return new URL(loc, base);\n                }\n\n                return new URL(\n                    loc,\n                    window.location.origin\n                );\n            };\n        }\n        return function getURL1(loc){\n            let a = document.createElement('a');\n            a.href = loc;\n            return a;\n        };\n    }else{\n\n        return function getURL2(loc, base){\n            let u = require('url');\n            let URL = u.URL;\n            if(loc[0] === '/'){\n                return new URL(loc, base || 'http://local');\n            }\n            return new URL(loc);\n        };\n    }\n})();\n\nexport { getURL, getSearch };\n","class View {\n    constructor(store){\n        this.store = store;\n        if(isNaN(store.expire)){\n            store.expire = Infinity;\n        }\n        this.start = Date.now();\n    }\n    get expire(){\n        return this.store.expire;\n    }\n    get expired(){\n        return this.expire === Infinity ? false : Date.now() >= (this.start + this.expire);\n    }\n    respond(){\n        this.store.respond();\n    }\n}\n\nView.isView = function(val){\n    return (typeof val === 'object' && 'respond' in val && typeof val['respond'] === 'function');\n};\n\nexport default View;\n","export class Branch {\n    constructor({\n        parent = {},\n        phrase = ''\n    } = {}){\n\n        const info = this.__info = {\n            name: phrase,\n            type: 'normal',\n            parent,\n            property: phrase,\n            child: null,\n            children: []\n        };\n\n        parent[phrase] = this;\n\n        if(phrase[0] === ':'){\n            info.type = 'parameter';\n            info.property = phrase.slice(1);\n            parent.__info.child = phrase;\n        }else if(phrase[0] === '*'){\n            info.type = 'splat';\n            info.property = phrase.slice(1);\n            parent.__info.child = phrase;\n        }else if(/^\\{[\\s\\S]+?\\}[\\s\\S]+$/.test(phrase)){\n            let [m, pattern, name] = phrase.match(/^\\{([\\s\\S]+?)\\}([\\s\\S]+)$/);\n            info.type = 'regex';\n            info.property = name;\n            info.pattern = new RegExp(pattern);\n            parent.__info.children.push(phrase);\n        }else if(/^[0-5]{3}/.test(phrase)){\n            info.type = 'error';\n        }\n    }\n    static leafFrom(branch, {\n        path = '',\n        handler = null,\n        type = null\n    } = {}){\n        branch.__info.type = type\n        ? type\n        : branch.__info.type;\n        branch.__info.handler = handler;\n        branch.__info.children = [];\n        branch.__info.path = path;\n        return branch;\n    }\n    static create({parent, phrase}){\n        if(parent[phrase]){\n            return parent[phrase];\n        }\n        return new Branch({parent, phrase});\n    }\n}\n\nexport class Tree {\n    constuctor(){\n        this.__info = {};\n    }\n    static branch(base, {path, handler}){\n        if(path === '/'){\n            base.__info = {\n                type: 'root'\n            };\n\n            return Branch.leafFrom(base, {\n                path,\n                handler,\n                type: 'root'\n            });\n        }\n\n        let leaf = path.split('/').slice(1)\n        .reduce((parent, phrase)=>{\n            return Branch.create({parent, phrase})\n        }, base);\n\n        return Branch.leafFrom(leaf, {path, handler});\n    }\n}\n","import { getURL, getSearch } from './url_stuff.js';\nimport View from './return_view.js';\nimport { Tree, Branch } from './tree.js';\nexport { Tree };\n\nexport class RouteResolver {\n    constructor(router, address, args, base){\n        this.router = router;\n        this.args = args;\n        this.address = address;\n        this.url = router.location = getURL(address, base);\n        this.pathname = this.url.pathname;\n        this.handler = null;\n        this.found = false;\n        this.params = {};\n        router.location = this.url;\n        this._route = null;\n    }\n    set route(route){\n        if(!route){ return; }\n        this._route = route;\n        this.handler = route.__info.handler;\n        this.found = true;\n        this.search = getSearch(this.url);\n    }\n    get route(){\n        return this._route;\n    }\n    get views(){\n        if(!this.route){\n            return {};\n        }\n        return this.route.__info.views;\n    }\n    matchRoute(){\n        //Do not change this method except for bugs, or clean up.\n        //Leave the algorithm intact.\n\n        let routes = this.router.routes;\n        let path = this.pathname;\n\n        if(path === '/' && routes.__info){\n            this.route = routes;\n            return this;\n        }\n\n        let parts = path.split('/').slice(1),\n            current = routes,\n            previous,\n            len = parts.length,\n            params = this.params,\n            section,\n            i = 0;\n\n        const setParam = (branch, value)=>{\n            params[branch.__info.property] = value;\n        };\n\n        const getChild = (branch)=>{\n            if(branch.__info.child){\n                return branch[branch.__info.child];\n            }\n        };\n\n        const matchChildren = (branch, section)=>{\n            let children = branch.__info.children, child;\n\n            const matchChild = (child)=>{\n                return section.match(child.__info.pattern);\n            };\n\n            for(let i=0; i<children.length; i++){\n                let child = branch[children[i]];\n                let match = matchChild(child);\n\n                if(match){\n                    setParam(child, match);\n                    return (current = branch[child.__info.name]);\n                }\n            }\n\n            return branch;\n        };\n\n        const useSplat = (branch)=>{\n            let value = [];\n            for(; i<len; i++){\n                if(branch[parts[i]]){\n                    break;\n                }\n                value.push(parts[i]);\n            }\n            setParam(branch, value);\n        };\n\n        for(i=0; i<len; i++){\n            let info;\n            section = parts[i];\n\n            previous = current;\n            current = current[section];\n\n            if(!current){\n\n                if(previous.__info.children.length){\n                    matchChildren(previous, section);\n                }\n\n                current = getChild(previous);\n\n                if(!current){ break; }\n            }\n\n            if(current.__info.type === 'parameter'){\n                setParam(current, section);\n            }else if(current.__info.type === 'splat'){\n                useSplat(current);\n            }\n        }\n\n        if(current){\n            this.route = current;\n        }\n\n        return this;\n    }\n    _getArguments(){\n        return [this.params, this.search].concat(this.args);\n    }\n    runRoute(){\n\n        if(!this.found){\n            let e = new Error('not found');\n            e.status = 404;\n            return Promise.reject(e);\n        }\n\n        return this.handler.apply(\n            this.router, this._getArguments()\n        );\n    }\n    resolve(){\n        return Promise.resolve()\n        .then(()=>this.matchRoute().runRoute());\n    }\n}\n","import { getURL, getSearch } from './url_stuff.js';\nimport { RouteResolver, Tree } from './route_tree.js';\nimport { throwError } from './throw_error.js';\n\nexport class Router {\n    constructor(options){\n        const self = this;\n        const relay = options['relay'];\n        const base = options['base'];\n        this['@@router'] = true;\n        //this.routes = {};\n        this.routes = new Tree();\n\n        if(typeof relay !== 'function'){\n            throw new Error('options.relay is not a function');\n        }\n\n        relay({\n            navigate(path, args=[]){\n                let resolver = new RouteResolver(self, path, args, base);\n                return resolver.resolve();\n            }\n        });\n    }\n    route(routes){\n        Object.keys(routes).forEach(pattern=>{\n            Tree.branch(this.routes, {\n                path: pattern,\n                handler: routes[pattern]\n            });\n            //createRouteTree(this.routes, pattern, routes[pattern]);\n        });\n        return this;\n    }\n    reject(message, data){\n        return throwError(message, data);\n    }\n}\n\n/*export class AbsoluteRouter {\n    constructor(routes){\n        this['@@router'] = true;\n        this.routes = {};\n\n        Object.keys(routes).forEach(pattern=>{\n            this.addRoute(pattern, routes[pattern]);\n        });\n    }\n    reject(message, data){\n        return throwError(message, data);\n    }\n    addRoute(pattern, handler){\n        createRouteTree(this.routes, pattern, handler);\n        return this;\n    }\n    navigate(path, args=[]){\n        if(typeof path === 'object'){\n            path = path.url;\n        }\n        let resolver = new RouteResolver(this, path, args);\n        return resolver.resolve();\n    }\n}\n\nexport function routing(routes, options={}){\n    return new AbsoluteRouter(routes, options);\n}*/\n","export function throwError(message, data={}){\n    const e = new Error(''+message);\n    Object.keys(data).forEach(key=>e[key]=data[key]);\n    return Promise.reject(e);\n}\n"],"names":["const","getSearch","window","document","url","let","full","entries","URLSearchParams","search","item","next","done","value","key","length","slice","split","reduce","param","name","getURL","loc","base","test","URL","location","origin","a","createElement","href","require","View","store","this","isNaN","expire","Infinity","start","Date","now","prototypeAccessors","expired","respond","isView","val","Branch","ref","info","__info","phrase","type","parent","property","child","children","match","pattern","RegExp","push","leafFrom","branch","handler","path","create","Tree","constuctor","leaf","RouteResolver","router","address","args","pathname","found","params","_route","route","views","matchRoute","routes","previous","section","parts","current","len","i","setParam","getChild","matchChildren","useSplat","_getArguments","concat","runRoute","e","Error","status","Promise","reject","apply","resolve","then","Router","options","self","relay","navigate","Object","keys","forEach","message","data","throwError"],"mappings":"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"}